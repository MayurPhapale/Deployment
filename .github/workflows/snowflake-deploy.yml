name: Snowflake Deployment

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - uat  

jobs:
  deploy_to_snowflake:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  

      - name: Debug Branch
        run: echo "Running on branch $GITHUB_REF_NAME"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install snowflake-connector-python sqlfluff jq

      - name: Get changed SQL files in Sorted order
        id: changed-files
        run: |
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}
          
          CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA | grep '\.sql$' || true)
          echo "Changed SQL files:"
          echo "$CHANGED_FILES"

          echo "$CHANGED_FILES" > changed_files.txt
          echo "sql_files=$(echo "$CHANGED_FILES" | tr '\n' ' ')" >> $GITHUB_ENV

      - name: Determine Databases and Map SQL Files
        id: set-db
        run: |
          BRANCH_NAME=${{ github.event.pull_request.head.ref }}
          TARGET_BRANCH=${{ github.event.pull_request.base.ref }}

          if [[ "$BRANCH_NAME" == uat_release* ]] && [[ "$TARGET_BRANCH" == "uat" ]]; then
            ENV_SUFFIX="_UAT"
          elif [[ "$BRANCH_NAME" == prod_release* ]] && [[ "$TARGET_BRANCH" == "main" ]]; then
            ENV_SUFFIX="_PROD"
          else
            echo "No matching database for this merge. Skipping deployment."
            exit 0
          fi

          get_database_name() {
            local folder=$1
            case $folder in
              com_dm) echo "DA_COM" ;;
              fin_dm) echo "DA_FIN" ;;
              mfg_dm) echo "DA_MFG" ;;
              mrkt_dm) echo "DA_MRKT" ;;
              prc_dm) echo "DA_PRC" ;;
              scm_dm) echo "DA_SCM" ;;
              udp) echo "DA_UDP" ;;
              *) echo "" ;;
            esac
          }

          DATABASES=""
          echo "" > sql_to_db_mapping.txt

          while IFS= read -r FILE; do
            FOLDER=$(echo "$FILE" | cut -d'/' -f1)
            DB_NAME=$(get_database_name "$FOLDER")

            if [[ -n "$DB_NAME" ]]; then
              DB_NAME="${DB_NAME}${ENV_SUFFIX}"
              DATABASES+="${DB_NAME}"$'\n'
              echo "$DB_NAME:$FILE" >> sql_to_db_mapping.txt
            fi
          done < changed_files.txt

          DATABASES=$(echo "$DATABASES" | sort -u)
          if [[ -z "$DATABASES" ]]; then
            echo "No valid databases found for deployment. Exiting."
            exit 0
          fi

          echo "Selected Databases:"
          echo "$DATABASES"

          echo "$DATABASES" > databases.txt
          echo "SNOWFLAKE_DATABASES=$(echo "$DATABASES" | tr '\n' ' ')" >> $GITHUB_ENV

      - name: Deploy changed SQL files to Snowflake
        if: ${{ env.sql_files != '' }}
        env:
          SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
          SNOWFLAKE_ROLE: ${{ secrets.SNOWFLAKE_ROLE }}
          SNOWFLAKE_WAREHOUSE: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          SNOWFLAKE_DATABASES: ${{ env.SNOWFLAKE_DATABASES }}
          SNOWFLAKE_SCHEMA: ${{ secrets.SNOWFLAKE_SCHEMA }}
          SNOWFLAKE_PRIVATE_KEY: ${{ secrets.SNOWFLAKE_PRIVATE_KEY }}
        run: |
          if [ ! -f sql_to_db_mapping.txt ] || [ ! -s sql_to_db_mapping.txt ]; then
            echo "No changed SQL files found. Exiting."
            exit 0
          fi

          cat > deploy.py << 'EOL'
		  import os
		  import snowflake.connector
		  import sys
		  
		  account = os.getenv('SNOWFLAKE_ACCOUNT')
		  user = os.getenv('SNOWFLAKE_USER')
		  role = os.getenv('SNOWFLAKE_ROLE')
		  warehouse = os.getenv('SNOWFLAKE_WAREHOUSE')
		  private_key = os.getenv('SNOWFLAKE_PRIVATE_KEY')
		  
		  conn = snowflake.connector.connect(
		  	account=account,
		  	user=user,
		  	private_key=private_key,
		  	role=role,
		  	warehouse=warehouse
		  )
		  cursor = conn.cursor()
		  
		  def split_sql_statements(sql_content):
		  	statements = []
		  	current_statement = []
		  	in_multiline_comment = False
		  
		  	for line in sql_content.splitlines():
		  		original_line = line
		  		line = line.strip()
		  
		  		if in_multiline_comment:
		  			if '*/' in line:
		  				line = line.split('*/', 1)[1]
		  				in_multiline_comment = False
		  			else:
		  				continue
		  
		  		if '/*' in line:
		  			if '*/' in line:
		  				line = line.split('/*', 1)[0] + line.split('*/', 1)[1]
		  			else:
		  				in_multiline_comment = True
		  				line = line.split('/*', 1)[0]
		  
		  		line = line.split('--')[0].split('#')[0].strip()
		  		if not line:
		  			continue
		  
		  		current_statement.append(original_line)
		  		if ';' in line:
		  			statements.append('\n'.join(current_statement))
		  			current_statement = []
		  
		  	if current_statement:
		  		statements.append('\n'.join(current_statement))
		  
		  	return statements
		  
		  def execute_sql_file(cursor, sql_file, database):
		  	try:
		  		cursor.execute(f"USE DATABASE {database};")
		  		with open(sql_file, "r") as f:
		  			sql_content = f.read()
		  
		  		print(f"Executing {sql_file} on {database}...")
		  		statements = split_sql_statements(sql_content)
		  
		  		for i, stmt in enumerate(statements):
		  			if stmt.strip():
		  				try:
		  					cursor.execute(stmt)
		  					print(f"  ✅ Statement {i+1}/{len(statements)} executed.")
		  				except Exception as e:
		  					print(f"  ❌ Error in statement {i+1}: {e}")
		  					raise Exception(f"Execution failed: {e}")
		  
		  		return True, None
		  
		  	except Exception as e:
		  		return False, str(e)
		  
		  with open("sql_to_db_mapping.txt", "r") as f:
		  	mappings = [line.strip().split(":", 1) for line in f.readlines() if ":" in line]
		  
		  success_count = 0
		  failure_count = 0
		  failed_files = []
		  
		  for db, file in mappings:
		  	success, error = execute_sql_file(cursor, file, db)
		  	if success:
		  		success_count += 1
		  		print(f"✅ {file} deployed to {db}")
		  	else:
		  		failure_count += 1
		  		failed_files.append(f"{file} on {db}: {error}")
		  
		  conn.close()
		  
		  print("\n----- DEPLOYMENT SUMMARY -----")
		  print(f"✔️  Successful: {success_count}")
		  print(f"❌ Failed: {failure_count}")
		  if failure_count > 0:
		  	print("\nFailures:")
		  	for fail in failed_files:
		  		print(f"  - {fail}")
		  	sys.exit(1)
		  else:
		  	print("🎉 All files deployed successfully!")
		  EOL
		  
		  		  python deploy.py
